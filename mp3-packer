#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2011 Martin Ueding <dev@martin-ueding.de>

"""
Creates lower bitrate versions of all music files in a file tree.

If you have a folder (and subfolders) full of music in a high bitrate, you
can use this program to create 128 kBit/s versions of each file. All
compressed files are cached in a hidden directory in your home directory. You
can then use a tool like C{rsync} to move the compressed music to your space
limited mobile device.

Say have two tracks in your library::

    /home/user/Musik/Artist/Album/14 - Track.mp3
    /home/user/Musik/Artist/Album/06 - Song.mp3

Call C{mp3-packer}::

    mp3-packer /home/user/Musik

After you call C{mp3-packer} you will have these files::

    /home/user/.cache/mp3_packer/128/home/user/Musik/Artist/Album/14 - Track.mp3
    /home/user/.cache/mp3_packer/128/home/user/Musik/Artist/Album/06 - Song.mp3
"""

from gettext import gettext
import optparse
import os
import shutil
import subprocess
import sys

tempnumber = 1
"""
Number the tempfiles start from.

@type: int
"""

def main():
    parser = optparse.OptionParser(usage=gettext("%prog path"), description=gettext("Traverses through a folder and creates a copy of the folder structure but compresses everything to a certain bitrate."))
    parser.add_option("--bitrate", dest="bitrate", type="int", default=128, help=gettext("bitrate in kbit [default: %default]"))
    parser.add_option("--engine", dest="engine", default="ffmpeg", help=gettext("engine to use (ffmpeg or lame) [default: %default]"))
    parser.add_option("-v", dest="verbose", action="store_true", help=gettext("show more information"))

    global options
    (options, args) = parser.parse_args()

    global engine
    engine = options.engine

    if len(args) != 1:
        print gettext("Call with -h to get help.")
        sys.exit(1)

    srcpath = os.path.abspath(args[0])
    global destpath
    destpath = os.path.expanduser("~/.cache/mp3_packer/"+str(options.bitrate))

    print gettext("reading from %s") % srcpath
    print gettext("writing to %s") % destpath
    print

    # Encode the all new files.
    os.path.walk(srcpath, parsefolder, options.bitrate)

    # Delete files that are no longer needed.
    os.path.walk(destpath, clearfolder, None)


def parsefolder(bitrate, dirname, names):
    """
    Looks at each file in a folder and encodes them if they do not exist in the
    destination folder.

    @param bitrate: Rate of target MP3 files.
    @type bitrate: int
    @param dirname: Directory name.
    @type dirname: str
    @param names: Files in this folder.
    @type names: list
    """
    if options.verbose:
        print "Parsing %s" % dirname

    for name in names:
        if name[-4:] == ".mp3" or name[-4:] == ".m4a":
            infile = dirname+"/"+name
            outfile = destpath+dirname+"/"+name[:-4]+".mp3"
            if not os.path.exists(outfile):
                encode(bitrate, infile, outfile)
            

def clearfolder(ignored, dirname, names):
    """
    Looks at each file in a cache folder and checks whether the original file
    for a chache file still exists in the original file tree. If not, the cache
    file is deleted.

    @param ignored: Ignored.
    @param dirname: Directory name.
    @type dirname: str
    @param names: Files in this folder.
    @type names: list
    """
    if options.verbose:
        print "Clearing %s" % dirname

    # If there are no names, this directory is empty. So it can be deleted.
    if len(names) == 0:
        os.rmdir(dirname)

    # Cut the cache dir from the path of the cache folder. This will yield the
    # position of the real file.
    realdir = dirname[len(destpath):]

    for name in names:
        # Construct the names of the real and cache file.
        currentfile = realdir+"/"+name
        cachefile = dirname+"/"+name

        if not (os.path.exists(currentfile) or os.path.exists(currentfile[:-4]+".m4a")):
            print "missing: %s" % currentfile
            if os.path.isdir(cachefile):
                shutil.rmtree(cachefile)
            else:
                os.remove(cachefile)


def encode(bitrate, infile, outfile):
    """
    Encodes a file with the already set engine.

    @param bitrate: Bitrate of target file.
    @type bitrate: int
    @param infile: Source audio file.
    @type infile: str
    @param outfile: Target audio file.
    @type outfile: str
    """
    # Create the dir so that lame does not complain.
    dir_of_infile = os.path.dirname(outfile)
    if not os.path.exists(dir_of_infile):
        os.makedirs(dir_of_infile)

    global tempnumber
    # TODO Hide this file from the user.
    tempfile = "mp3_packer-temp-%d.mp3" % tempnumber
    tempnumber += 1

    # Encode the file.
    print gettext("encoding %s") % infile
    if engine == "lame":
        command = ['lame', '--quiet', '-b', bitrate, infile, tempfile]
    if engine == "ffmpeg":
        command = ['ffmpeg', '-i', infile, '-map_metadata', "%s:%s" % (infile, infile), '-acodec', 'libmp3lame', "-ac", "2", "-ab", "%dk" % bitrate, tempfile]

    try:
        if subprocess.call(command) == 0:
            os.rename(tempfile, outfile)
        else:
            encode_cleanup(tempfile)
    except KeyboardInterrupt:
        encode_cleanup(tempfile)


def encode_cleanup(tempfile):
    """
    Delete the tempfile in case anything went wrong.
    
    @param tempfile: File to delete.
    @type tempfile: str
    """
    if os.path.exists(tempfile):
        os.remove(tempfile)


if __name__ == "__main__":
    main()
